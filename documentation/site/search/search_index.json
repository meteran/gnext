{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":"<p>gNext is a Golang API-focused framework extending Gin. Offers the API structuring, automates validation and generates documentation. It's compatible with the existing Gin handlers and Gin middlewares. Designed to simplify and boost development of JSON APIs. You can leave generic and boring stuff to gNext and purely focus on the business logic.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can download gNext and install it in your project by running:</p> <pre><code>$ go get -u github.com/meteran/gnext\n---&gt; 100%\n</code></pre>"},{"location":"first-steps/","title":"First steps","text":"<p>This tutorial assumes, that you already have Golang installation and basic knowledge about how to build and run Go programs. If this is your first hit with Go, and you feel you have no idea what is happening here, please read how to get started with Go.</p> <p>Ok, so let's create a project:</p> <pre><code>$ mkdir gnext-example\n$ cd gnext-example\n$ go mod init example.com/gnext\n$ go get -u github.com/meteran/gnext\n---&gt; 100%\n</code></pre> <p>Create a file <code>example.go</code> and fill it up with the following code:</p> <pre><code>package main\nimport \"github.com/meteran/gnext\"\nfunc main() {\nr := gnext.Router()\nr.GET(\"/example\", func() string {\nreturn \"Hello World!\"\n})\n_ = r.Run()\n}\n</code></pre> <p>Run it:</p> <pre><code>$ go run example\n</code></pre> <p>Now you can visit this link in your browser: http://localhost:8080/example</p> <p>Yes, yes... of course it works, but that's boring... Let's open this page: http://localhost:8080/docs</p> <p>Whoa, that was amazing, ...but not very useful.</p> <p>Let's try some real example. With request and response. We can modify our handler to use structures:</p> <pre><code>package main\nimport \"github.com/meteran/gnext\"\nfunc main() {\nr := gnext.Router()\nr.POST(\"/example\", handler)\n_ = r.Run()\n}\ntype MyRequest struct {\nId   int    `json:\"id\" binding:\"required\"`\nName string `json:\"name\"`\n}\ntype MyResponse struct {\nResult string `json:\"result\"`\n}\nfunc handler(req *MyRequest) *MyResponse {\nreturn &amp;MyResponse{Result: req.Name}\n}\n</code></pre> <p>Restart the server and visit the docs page. You can see that request and response of <code>POST /example</code> endpoint are documented. That's the real power!</p> <p>The POST request without required <code>id</code> now fails with the validation error:</p> <pre><code>$ curl --request POST http://localhost:8080/example --data '{\"name\": \"some name\"}'\n</code></pre> <p>gives output:</p> <pre><code>{\n\"message\": \"validation error\",\n\"details\": [\n\"field validation for 'id' failed on the 'required' tag with value ''\"\n],\n\"success\": false\n}\n</code></pre> <p>the valid request:</p> <pre><code>$ curl --request POST http://localhost:8080/example --data '{\"name\": \"some name\", \"id\": 4}'\n</code></pre> <p>gives us the expected response:</p> <pre><code>{\n\"result\": \"some name\"\n}\n</code></pre> <p>Congratulations! Now you are prepared for the fast forwarding development of your great API.</p>"},{"location":"advanced-guide/gin-context/","title":"Gin context","text":"<p>It is possible to use the raw gin context. Just add to your middleware/handler an argument of type <code>*gin.Context</code>:</p> <pre><code>func getShopsList(c *gin.Context, q *ShopQuery, h *MyHeaders) (*MyResponse, gnext.Status){\nreturn &amp;MyResponse{Result: c.Request.Method}, http.StatusOK\n}\n</code></pre>"},{"location":"user-guide/endpoint-groups/","title":"Endpoint groups","text":"<p>As in the standard GinGonic and many frameworks, we support Endpoint Groups.</p> <p>We use them not only for structuring, we can also add gNext middleware or gNext error handler to them.</p> <p>Let's have a look at a simple example to create a group:</p> <pre><code>func main() {\nr := gnext.Router()\nr.POST(\"/example\", handler)\nr.Group(\"/shops\").\nGET(\"/\", getShopsList).\nGET(\"/:name/\", getShop)\n_ = r.Run()\n}\n</code></pre> <p>Okay, now we can restart the server using the previously created endpoints in exactly the same way.</p> <p>Note: using middleware and error handler for the group will be presented in their individual documentation sections.</p>"},{"location":"user-guide/error-handling/","title":"Error handling","text":""},{"location":"user-guide/error-handling/#in-general","title":"In general","text":"<p>Whenever a middleware or handler returns a value which implements <code>error</code> interface, the execution flow is frozen and appropriate error handler is called. To create an error handler, you need to implement a function with the following  rules:</p> <ol> <li>Takes exactly one argument, which type implements <code>error</code> interface.</li> <li>Can not return an <code>error</code>.</li> <li>Values returned from error handler behave similarly like from a middleware.</li> <li>Should return a response, because the handler might not be called.</li> </ol> <p>The simplest example can look like:</p> <pre><code>func errorHandler(err error) (string, gnext.Status) {\nreturn err.Error(), 500\n}\n</code></pre> <p>Register it in the router:</p> <pre><code>r.OnError(errorHandler)\n</code></pre> <p>Now every returned error will be handled by our custom error handler.</p>"},{"location":"user-guide/error-handling/#default-handler","title":"Default handler","text":"<p>If you don't register any error handler, the default one will be called, which gracefully handles the following errors:</p> <ul> <li><code>*json.SyntaxError</code></li> <li><code>*json.UnmarshalTypeError</code></li> <li><code>validator.ValidationErrors</code></li> <li><code>*gnext.NotFound</code></li> </ul> <p>You probably noticed, that in documentation of your API, next to your response, there are error responses.  They come from the default error handler definition which returns the following response struct:</p> <pre><code>type DefaultErrorResponse struct {\nErrorResponse `default_status:\"500\" status_codes:\"4XX,5XX\"`\nMessage       string   `json:\"message\"`\nDetails       []string `json:\"details\"`\nSuccess       bool     `json:\"success\"`\n}\n</code></pre> <p>There are 3 status codes defined in response above.  That's why in your documentation there are <code>500</code>, <code>4XX</code> and <code>5XX</code> status codes with the response scheme above.</p>"},{"location":"user-guide/error-handling/#error-response","title":"Error response","text":"<p>In order to document error response scheme, you need to define a response structure. It will be similar to the one in default response. Example:</p> <pre><code>type MyResponse struct {\nMessage       string   `json:\"message\"`\nSuccess       bool     `json:\"success\"`\n}\n</code></pre>"},{"location":"user-guide/error-handling/#http-status","title":"HTTP status","text":"<p>You can define HTTP status returned together with the error response just inside a struct. To do that, you need to mark your struct as an error response and add <code>default_status</code> tag.</p> <pre><code>type MyResponse struct {\ngnext.ErrorResponse `default_status:\"422\"`\nMessage             `json:\"message\"`\n}\n</code></pre> <p>Now, you can simplify your error handler and don't return a status:</p> <pre><code>func errorHandler(err error) *MyResponse {\nreturn &amp;MyResponse{Message: err.Error()}\n}\n</code></pre> <p>gNext will document <code>MyResponse</code> scheme under <code>422</code> HTTP status code. It will also use it in response as a default status code. You can override it, by returning <code>gnext.Status</code> from handler:</p> <pre><code>func errorHandler(err error) (*MyResponse, gnext.Status) {\nresponse := &amp;MyResponse{Message: err.Error()}\nif response.Message == \"not found\" {\nreturn response, 404\n}\nreturn response, 400\n}\n</code></pre> <p>This will return <code>404</code> HTTP status code if the error message is <code>not found</code>. However, <code>404</code> code won't be documented. To add additional status codes to documentation, you need to write comma-separated statuses to <code>status_codes</code> tag of <code>gnext.ErrorResponse</code>:</p> <pre><code>type MyResponse struct {\ngnext.ErrorResponse `default_status:\"422\" status_codes:\"400,404\"`\nMessage             `json:\"message\"`\n}\n</code></pre> <p>Now you will see the error response with all three codes.</p> <p>Warning</p> <p>OpenAPI v3 scheme keeps responses in a map: status code -&gt; response schema.  This means, it is not possible to document more than one response scheme for one status code. If you register more than one response with the same status code, the random one will be exposed in documentation.</p>"},{"location":"user-guide/headers/","title":"Headers","text":"<p>It happens that we want to do something with the request <code>Headers</code> - nothing difficult.</p> <p>Look, I will add the headers structure and use it in the handler:</p> <pre><code>type MyHeaders struct {\ngnext.Headers\nContentType string `header:\"Content-Type,default=application/json\"`\n}\nfunc getShopsList(q *ShopQuery, h *MyHeaders) (*MyResponse, gnext.Status){\nreturn &amp;MyResponse{Result: h.ContentType}, http.StatusOK\n}\n</code></pre> <p>Ok, now restart the server and use endpoint:</p> <pre><code>$ curl -X 'GET' \\\n'http://localhost:8080/shops/' \\\n-H 'accept: application/json'\n</code></pre> <p>the response will look like this:</p> <pre><code>{\n\"result\": \"application/json\"\n}\n</code></pre> <p>It's simple, isn't it? Of course, you can enter headers in the Swagger interface \ud83e\udee1</p>"},{"location":"user-guide/middlewares/","title":"Middlewares","text":""},{"location":"user-guide/middlewares/#authorization","title":"Authorization","text":"<p>Almost every application needs some authorization and authentication mechanism.  To be compliant with DRY and to avoid boilerplate code, most frameworks use middleware for such stuff. gNext also allows you to write middlewares in.</p> <p>Let's take a simple user model in <code>users.go</code> file:</p> users.go<pre><code>type User struct {\nId    int    `json:\"id\"`\nName  string `json:\"name\"`\nAge   int    `json:\"age\"`\nToken string `json:\"-\"`\n}\n</code></pre> <p>And a list of user:</p> users.go<pre><code>var users = []*User{\n{\nId:    0,\nName:  \"Krzesimir\",\nAge:   34,\nToken: \"token-1\",\n},\n{\nId:    1,\nName:  \"Ziemowit\",\nAge:   42,\nToken: \"token-2\",\n},\n}\n</code></pre> <p>Security alert</p> <p>For simplicity, we use a plain text tokens in this example. Normally user authorization should be secured using e.g. JWT.</p> <p>Let's say, that everyone who is authorized can see information about any other user (file: <code>example.go</code>).</p> example.go<pre><code>func handler(userId int) (*User, gnext.Status) {\nfor _, usr := range users {\nif usr.Id == userId {\nreturn usr, http.StatusOK\n}\n}\nreturn nil, http.StatusNotFound\n}\nfunc main() {\nr := gnext.Router()\nr.GET(\"/users/:id/\", handler)\n_ = r.Run(\"\", \"8080\")\n}\n</code></pre> <p>After running it, you can try it out directly from the docs. But now, everyone can see any user without authorization. Let's define a middleware then.</p> <p>Middleware is a function which looks very similarly to handler.  It can be executed before or after handler and have input and output parameters.  As input parameters you can use the same request data as in handler. Output parameters can be used in next middlewares and handler.</p> <p>So let's create an authorization middleware, which will check a token provided in <code>Authorization</code> header.  If token doesn't exist nor belong to some user, we want to stop the flow, not running handler.  </p> middleware.go<pre><code>import (\n\"fmt\"\n\"github.com/meteran/gnext\"\n)\ntype AuthorizationHeaders struct {\ngnext.Headers\nAuthorization string `header:\"Authorization\"`\n}\nfunc authorizationMiddleware(headers *AuthorizationHeaders) (*User, error) {\nfor _, usr := range users {\nif usr.Token == headers.Authorization {\nreturn usr, nil\n}\n}\nreturn nil, fmt.Errorf(\"unauthorized\")\n}\n</code></pre> <p>And use this middleware before we set up a handler:</p> example.go<pre><code>func main() {\nr := gnext.Router()\nr.Use(gnext.Middleware{\nBefore: authorizationMiddleware,\n})\nr.GET(\"/users/:id/\", handler)\n_ = r.Run(\"\", \"8080\")\n}\n</code></pre> <p>Now only authorized users can access the data. The rest will get an unhandled error - 500. Any values with custom types returned from the middleware can be passed to a next middleware or a handler as an input parameter. Knowing that, we can modify our handler to take a current user (recognized by a token) as a handler parameter:</p> example.go<pre><code>func handler(userId int, actor *User) (*User, gnext.Status) {\nlog.Printf(\"actor: %v\", actor)\nfor _, usr := range users {\nif usr.Id == userId {\nreturn usr, http.StatusOK\n}\n}\nreturn nil, http.StatusNotFound\n}\n</code></pre> <p>gNext has mapped the user object by type <code>*User</code>.  It recognized, that a middleware has output parameter <code>*User</code> and handler has an input parameter of the same type, and it called handler with <code>*User</code> value. If you want to catch the returned error, you should read about error handling in gNext.</p>"},{"location":"user-guide/middlewares/#metrics-and-monitoring","title":"Metrics and monitoring","text":"<p>Now we would like to monitor our server logging two things - how much time the endpoint execution took and what status code was returned. We will start from status code. Let's create a new file <code>metrics.go</code> and log the returned status code.</p> metrics.go<pre><code>func metricsAfterMiddleware(status gnext.Status) {\nlog.Printf(\"status: %d\", status)\n}\n</code></pre> <p>Register it in router:</p> example.go<pre><code>func main() {\nr := gnext.Router()\nr.Use(gnext.Middleware{\nAfter:  metricsAfterMiddleware,\n})\nr.Use(gnext.Middleware{\nBefore: authorizationMiddleware,\n})\nr.GET(\"/users/:id/\", handler)\n_ = r.Run(\"\", \"8080\")\n}\n</code></pre> <p>If we make a call to our endpoint, the metrics middleware will be executed after the handler, and will get the HTTP status code which is supposed to be returned.</p> <p>Note</p> <p>Metrics middleware is registered before the authorization one. This will be important later.</p> <p>That was quite easy, because we implemented stateless middleware.  To calculate how much time the request took, we need to forward the start time from one middleware to another. As I mentioned in the section above, we can return value of any custom type from middleware, and if handler or another middleware takes it as an argument, it will be forwarded. So let's create out context type to pass it between middlewares:</p> metrics.go<pre><code>type metricsContext struct {\nstartedAt time.Time\n}\n</code></pre> <p>Create a new middleware to make a context and modify our current middleware to use it.</p> metrics.go<pre><code>func metricsBeforeMiddleware() *metricsContext {\nreturn &amp;metricsContext{time.Now()}\n}\nfunc metricsAfterMiddleware(ctx *metricsContext, status gnext.Status) {\nlog.Printf(\"execution time: %v, status: %d\", time.Now().Sub(ctx.startedAt), status)\n}\n</code></pre> <p>The value of type <code>*metricsContext</code> is created and returned from <code>metricsBeforeMiddleware</code>. <code>metricsAfterMiddleware</code> takes value of the same type, so gNext calls it with the value returned from <code>metricsBeforeMiddleware</code>.</p> <p>Important</p> <p>Pointer to some type is not the same as that type (<code>*A != A</code>). If one middleware returns <code>*A</code> and another one gets <code>A</code>,  the second middleware/handler will get a new zero value of <code>A</code> instead of the value returned from the first middleware. In this case it will be a context with zero time value, and the execution time will be calculated incorrectly (counted in years). Unfortunately there is no error in case the middleware/handler takes a not existing value. The zero value is being created in order to allow fallback execution after error handling. Be sure, you have exactly the same type in all middlewares/handler which uses the same value.</p> <p>And register new middleware to the router:</p> example.go<pre><code>func main() {\nr := gnext.Router()\nr.Use(gnext.Middleware{\nBefore: metricsBeforeMiddleware,\nAfter:  metricsAfterMiddleware,\n})\nr.Use(gnext.Middleware{\nBefore: authorizationMiddleware,\n})\nr.GET(\"/users/:id/\", handler)\n_ = r.Run(\"\", \"8080\")\n}\n</code></pre> <p>Now we can see why the registration order is important.  <code>metricsBeforeMiddleware</code> will save the start time before <code>authorizationMiddleware</code> execution. If we change the registration order, the start time would be checked after <code>authorizationMiddleware</code>, and its execution time would be excluded.</p> <p>So how does the execution chain look like now:</p> <pre><code>sequenceDiagram\n    participant Server\n    participant Metrics\n    participant Authorization\n    participant Handler\n\n    Server -&gt;&gt;+ Metrics: request\n    Metrics -&gt;&gt;- Authorization: metrics context\n    activate Authorization\n    Authorization -&gt;&gt;- Handler: user\n    activate Handler\n    Handler -&gt;&gt;- Metrics: status code\n    activate Metrics\n    Metrics -&gt;&gt;- Server: response\n</code></pre> <p>Remember</p> <p>The order of middleware registration determines the order of their execution. </p>"},{"location":"user-guide/path-parameters/","title":"Path parameters","text":"<p>Okay, in the previous section we saw quick use, let's get to specific things \ud83d\ude0e</p> <p>First, we'll start with the parameters in the url.</p> <p>Using them the standard way is unpleasant, we have to write a piece of code in the handler method just to be able to use it knowing the type safely - not cool.</p> <p>But... gNext will do it for us \ud83e\udd73!</p> <p>Let's see, I'll add a new endpoint with parameter and add handler method to it:</p> <pre><code>func main() {\nr := gnext.Router()\nr.POST(\"/example\", handler)\nr.GET(\"/shops/:name/\", getShop)\n_ = r.Run()\n}\nfunc getShop(paramName string) *MyResponse {\nreturn &amp;MyResponse{Result: paramName}\n}\n</code></pre> <p>Ok, now restart the server and use a new endpoint:</p> <pre><code>$ curl -X 'GET' \\\n'http://localhost:8080/shops/myownshop/' \\\n-H 'accept: application/json'\n</code></pre> <p>the response will look like this:</p> <pre><code>{\n\"result\": \"myownshop\"\n}\n</code></pre> <p>Cool, yeah? Let's take a look at http://localhost:8080/docs, but ... don't be surprised when</p> <p>you will see a documented endpoint <code>/shops/{name}/</code>  ready to use straight from the Swagger interface \ud83d\udc4f</p> <p>Note:  adding new parameters as arguments to the handler methods, keep the order in accordance with the parameters in the url.</p>"},{"location":"user-guide/query-parameters/","title":"Query parameters","text":"<p>Okay, let's move on to a topic with a similar problem as in the previous section - Query parameters.</p> <p>Exactly the same problem as with url parameters, to use them we have to add a piece of code, but why not use the magic of gNext \ud83c\udfa9?</p> <p>Let's add some query parameter to our new shop list endpoint<code>/shops/</code>:</p> <p><pre><code>func main() {\nr := gnext.Router()\nr.POST(\"/example\", handler)\nr.GET(\"/shops/\", getShopsList)\nr.GET(\"/shops/:name/\", getShop)\n_ = r.Run()\n}\ntype ShopQuery struct {\ngnext.Query\nSearch       string    `form:\"search\"`\n}\nfunc getShopsList(q *ShopQuery) *MyResponse {\nreturn &amp;MyResponse{Result: q.Search}\n}\n</code></pre> As you could see, the query struct is marked as query using the base struct <code>gnext.Query</code>. Some structs have to be marked in order to inform gNext what part of request it represents. If there is just one data structure of unknown request part, it is considered depending on the HTTP method:</p> <ul> <li><code>GET</code>, <code>DELETE</code>, <code>HEAD</code>, <code>OPTIONS</code> - unknown argument is considered as query parameters</li> <li><code>POST</code>, <code>PUT</code>, <code>PATCH</code> - unknown argument is considered as request body</li> </ul> <p>So, if you want to catch the query params in <code>GET</code> request, and all other parameters don't exist, or are marked as headers, url params, you don't need to mark the structure as <code>gnext.Query</code>.</p> <p>If there is more than one unknown structure, the gNext will panic during handler creation.</p> <p>Ok, now restart the server and use a new endpoint:</p> <pre><code>$ curl -X 'GET' \\\n'http://localhost:8080/shops/?search=wantedshop' \\\n-H 'accept: application/json'\n</code></pre> <p>the response will look like this:</p> <pre><code>{\n\"result\": \"wantedshop\"\n}\n</code></pre> <p>As before, in the documentation we find a new endpoint ready to be used by the interface \ud83d\udc77\u200d\u2640\ufe0f</p> <p>It is important, that in one request, you can have only one query parameters structure. Using the following handler will panic: <pre><code>type ShopQuery struct {\ngnext.Query\nSearch       string    `form:\"search\"`\n}\ntype ShopSecondQuery struct {\ngnext.Query\nOrder       string    `form:\"order\"`\n}\nfunc getShopsList(q1 *ShopQuery, q2 *ShopSecondQuery) *MyResponse {\n...\n}\n</code></pre></p>"},{"location":"user-guide/request-body/","title":"Request body","text":"<p>As you could see in the First steps section, you can define the request payload as your own structure. It will be parsed then to fill the documentation. When request is made, its body is bound to the given structure using gin-binding module. This implies body validation using the validator package. If there is a validation error, the error from gin's <code>Context.ShouldBindWith</code> method will be raised. Be sure, you have an error handler listening on such errors.</p> <p>Because the handler arguments can be mixed, gNext has to recognize which parameter should be bound to the body. To mark structure as a request body, use a base struct inside:</p> <pre><code>type MyRequest struct {\ngnext.Body\nId   int    `json:\"id\" binding:\"required\"`\nName string `json:\"name\"`\n}\n</code></pre>"},{"location":"user-guide/response-status-code/","title":"Response status codes","text":"<p>In this section we will show you returning statuses with gNext \ud83d\ude4c.</p> <p>It's simple, just add <code>gnext.Status</code> to the returned handler parameters</p> <p>Example:</p> <pre><code>func getShopsList(q *ShopQuery)(*MyResponse, gnext.Status) {\nreturn nil, http.StatusNotFound\n}\n</code></pre> <p>Ok, now restart the server and use endpoint:</p> <pre><code>$ curl -X 'GET' \\\n'http://localhost:8080/shops/?search=wantedshop' \\\n-H 'accept: application/json'\n</code></pre> <p>And the response status we will be <code>404</code> \ud83e\uddbe</p>"}]}